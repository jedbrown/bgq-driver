#!/usr/bin/perl

=head1 NAME

B<doxygen.pl>

=head1 COPYRIGHT

(C)Copyright IBM Corp.  2007, 2007
IBM CPL License

=head1 SYNOPSIS

 doxygen.pl [-h] [--help]
 doxygen.pl [--base=] [--devices=] [--protocols=] [--messager=] [--tests=] [--sysdep=] [Option=arg] [Doxyfile]

=head1 DESCRIPTION

Aids in setting up doxygen runs on the messager codebase

=head2 OPTIONS

There are a couple extra features on these arguments.  Due to the
parsing method, many of the options can take a list of files
(B<list>), or the option can be specified several times resulting in a
cumulative effect (B<multi-arg>)

=over

=item B<-h>

Prints a help message and exits.

=item B<--help>

Prints a help message as a man page and exits.

=item B<--base>=I<dir>

Location of the source code base directory.  When running from the
build tree, this would generally be the one I<containing> C<sysdep>.
This is only important when not parsing from C<${PWD}>

Command line optionas are parsed in order, and the --base=I<<dir>>
option causes the C<${PWD}> to change at the moment it it seen.  B<Its
placement in the argument list is therefore quite important.> [sorta
multi-arg]

=item B<--output>=...

This specifies where exactly the output is to be sent.

=item B<--input>=...

This simply lists a file/directory (relative to the current --base)
that should be included in the list of items to parse.  [multi-arg,
list]

=item --I<<Directory>>=<list>

I<<Directory>> entries from the C<Make.rules> file:
 --devices    => ${DEVICES}
 --protocols  => ${PROTOCOLS}
 --messager   => ${MESSAGER}
 --tests      => ${TESTS}
 --sysdep     => ${PLATFORM}

These entries allow B<doxygen.pl> create the requisite list of files
to parse when creating doxygen for the configured build tree.  Because
they have other side effects, such as including certain headers and
examples, it is best not to attempt to use them unless you are
actually building out of a configured build tree.  [multi-arg, list]

=item B<--settings>

This is a debug flag which causes the application to only print out
the config info which would normally be passed to doxygen

=item B<Option=arg>

Arguments that do contain a B<=> are assumed to be extra doxygen
configuration options.

=item B<<file>>

Those arguments that do not contain a B<=> are assumed to be files.
If a file cannot be found, it is a fatal error (except for B<->, which
is a shortcut for STDIN).

Files are printed to doxygen before any of the specific options set
using the command-line switches.

=back

=head2 Ouptut order

Configuraton output is sent to doxygen in the following order:

=over

=item 1

B<Files> are the first items printed, verbatim & in the order
specified.  These are considered to be the defaults.

=item 2

The config options generated by the B<command-line switches> are
the next to be printed.  They are done in the middle since they might
overstate the user's goals.

=item 3

The B<Option=arg> list is the last item to be printed

=back

=head2 EXAMPLES

=over

=item B<doxygen.pl>

  I'll get to this part.

=back

=cut

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Cwd qw'abs_path chdir';
use File::Find;

$|=1;
sub main();
sub initialize();
sub printer();
sub forker();
sub dcmf_dirs();
sub ccmi_dirs();
sub clean_dir(@);
sub parse_dir($@);
sub parse_subdirs($@);
sub parse_protocols($@);
sub parse_input($@);
sub parse_sysdep($@);
sub parse_messager($@);
sub ersu(@);
sub read_argv();

my %opts = qw(base .);
my (@dlist,%extra)=();
my $top_build_dir = $ENV{PWD};


main();
exit;



sub main()
{
    initialize();
    read_argv();
    unless (@dlist) {
        push @dlist, '.';
    }
    @dlist = ersu(@dlist);
    forker();
    printer();
    print '-'x77, "\n" if ($opts{settings})
}


sub initialize()
{
    my $i;
    my %dirs =
    (
     subdirs    => \&parse_subdirs,
     devices    => \&parse_dir,
     protocols  => \&parse_protocols,
     messager   => \&parse_messager,
     tests      => \&parse_dir,
     sysdep     => \&parse_sysdep,
    );
    my %config_dirs = map {( "$_=s" => $dirs{$_} )} keys %dirs;
    my %config_opts =
        (%config_dirs,
         "help"     => sub { pod2usage(-exitstatus => 0, -verbose => 2); },
         "h"        => sub { pod2usage(-exitstatus => 0, -verbose => 1); },
         "list:s"   => sub { print map {"|$_|\n"} @_ },
         "settings" => \$opts{settings},
         "base=s"   => sub { my($command,$arg)=@_; chdir($arg) or die "Could not find $arg: $!"; },
         "output=s" => \$extra{OUTPUT_DIRECTORY},
         "deps:s"   => \&parse_deps,
         "input=s"  => \&parse_input,
        );

    GetOptions(%config_opts)
        or die "Incorrect argument specification\n";
}


sub read_argv()
{
    my @argv = ();
    for my $i (@ARGV) {
        if ( ($i eq '-') or (-e $i) ) {
            push @argv, $i;
        } elsif ($i =~ m/^(\S+)\s*=\s*(.*)/) {
            $extra{$1} = $2;
        } else {
            die "No idea how to handle this arg : '$i'\n";
        }
    }
    @ARGV = @argv;
    my $local_doxyfile = "Doxyfile";
    unless (@ARGV) {
        @ARGV = (-e $local_doxyfile)? ($local_doxyfile) : qw'-';
    }
}


sub forker()
{
    if ($opts{settings}) {
        print '-'x77, "\n";
        printf("Using DOXYFILE from : %s\n", join(', ', @ARGV));
    } else {
        my $pid = undef;
        unless ($pid = open(STDIN, "-|")) {
            die "cannot fork: $!" unless defined $pid;
            return $pid;
        }
#        exec(qw(cat -n));
        system(qw(which doxygen));
        system(qw(doxygen --version));
        exec(qw'/usr/bin/time doxygen -');
        exit(1);
    }
}


sub parse_subdirs($@)
{
    my $i = shift;
    my @new = clean_dir(@_);
    push @dlist, map {"$_"} @new;
}


sub parse_dir($@)
{
    my $i = shift;
    my @new = clean_dir(@_);
    push @dlist, map {"$i/$_"} @new;
}


sub parse_deps($@)
{
    shift;
    my  @deps  = ();
    our @found = ();

    sub wanted() {
        return if ($File::Find::name =~ m@/CVS@);
        return if ($File::Find::name =~ m@/test@);

        if (-d $_) {
        } elsif (-f $_) {
            if (m@\.d$@) {
                push(@found, $File::Find::name);
            }
        } else {
            warn "$File::Find::name (skipped)\n";
        }
    }
    find(\&wanted, @_);

    return unless scalar @found;
    local @ARGV = @found;
    while(<>) {
        chomp;
        next unless m/./;
        next if m/:/;
        s/^\s+//g;
        s/\s+\\$//g;
        push(@deps, $_);
    }

    push @dlist, @deps;
}


sub parse_input($@)
{
    shift;
    my @new = clean_dir(@_);
    push @dlist, @new;
}


sub parse_protocols($@)
{
    my $i = shift;
    my @new = clean_dir(@_);
    push @dlist, map {"$i/$_"} @new;
    push @dlist, glob "$i/contrib/*.h";
    push @dlist, glob "$i/prod/*.h";
}


sub parse_sysdep($@)
{
    my $dir;
    my $i = shift;
    my @new = clean_dir(@_);
    foreach (@new) {
        if (-e ($dir = "$i/prod/$_"))
        {}
        elsif (-e ($dir = "$i/contrib/$_"))
        {}
        else
        {
            die "Could not find the sysdep $_";
        }
        push @dlist, $dir;
    }
    push @dlist, glob("sysdep/*.h");
}


sub parse_messager($@)
{
    my $i = shift;
    my @new = clean_dir(@_);
    push @dlist, map {"$i/$_"} @new;
    push @dlist, map {( glob "$i/*.h" )}        @new;
    push @dlist, map {( glob "$i/$_/../*.h" )}  @new;
    push @dlist, map {( glob "$i/$_/../*.cc" )} @new;
}


sub clean_dir(@)
{
    my $list = join(' ', @_);
    $list =~ s/^\s+//;
    $list =~ s/\s+$//;
    return split(/\s+/, $list);
}


sub ersu()
# Exists
# Realpath
# Sort
# Unique
{
    my %seen = ();
    return sort grep { !$seen{$_}++ } map { Cwd::abs_path($_) } grep { -e $_ } @_;
}


sub printer()
{
    unless ($opts{settings}) {
        print while (<>);
    }
    foreach (keys %extra) {
        print "$_ = $extra{$_}\n" if defined $extra{$_};
    }
    print "INPUT = \\\n   ";
    print join("  \\\n   ", sort @dlist);
    print "\n";
}


=head1 BUGS

Using files and --base is a problem because we actually chdir before
opening the files.

=head1 AUTHOR

Email jratt@us.ibm.com with questions.

=cut
